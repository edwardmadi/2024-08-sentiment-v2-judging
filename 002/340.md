Flat Navy Bee

High

# Superpool is vulnerable to donation attack

## Summary

Currently, Superpool tracks ERC4626 `totalAssets` using `ASSET.balanceOf(address(this))`. Victim's funds can be lost through exchange rate manipulation. Even if `SuperPoolFactory` burns some initial share before the pool is deployed, donations can still be realized by frontrunning `deploySuperPool` and transferring asset tokens to the pool address.

## Vulnerability Detail

A malicious user can perform a donation to execute a classic first depositor/ERC4626 inflation Attack against the Superpool vault. The general process of this attack is well-known, and a detailed explanation of this attack can be found in many of the resources such as the following:

https://blog.openzeppelin.com/a-novel-defense-against-erc4626-inflation-attacks
https://mixbytes.io/blog/overview-of-the-inflation-attack

In short, to kick-start the attack, the malicious user will often usually mint the smallest possible amount of shares (e.g., 1 wei) and then donate significant assets to the vault to inflate the number of assets per share. Subsequently, it will cause a rounding error when other users deposit.

In Superpool, the total assets used when users mint shares or redeem assets is `lastTotalAssets`. However, `lastTotalAssets` is updated through `accure()`:

```solidity
    function simulateAccrue() internal view returns (uint256, uint256) {
        uint256 newTotalAssets = totalAssets();
        uint256 interestAccrued = (newTotalAssets > lastTotalAssets) ? newTotalAssets - lastTotalAssets : 0;
        if (interestAccrued == 0 || fee == 0) return (0, newTotalAssets);

        uint256 feeAssets = interestAccrued.mulDiv(fee, WAD);
        // newTotalAssets already includes feeAssets
        uint256 feeShares = _convertToShares(feeAssets, newTotalAssets - feeAssets, totalSupply(), Math.Rounding.Down);

        return (feeShares, newTotalAssets);
    }

    function totalAssets() public view returns (uint256) {
        uint256 assets = ASSET.balanceOf(address(this));

        uint256 depositQueueLength = depositQueue.length;
        for (uint256 i; i < depositQueueLength; ++i) {
            assets += POOL.getAssetsOf(depositQueue[i], address(this));
        }

        return assets;
    }
```

Instead tracking `ASSET` balance virtually, contract simply uses `ASSET.balanceOf(address(this));`. So attacker can directly send tokens to Superpool as "Fake yield" to inflate the asset/share price.

However, `SuperPoolFactory` burns some initial shares when a new superpool is created, which makes it necessary to take some other steps to bypass this measure.

```solidity
    function deploySuperPool(
        address owner,
        address asset,
        address feeRecipient,
        uint256 fee,
        uint256 superPoolCap,
        uint256 initialDepositAmt,
        string calldata name,
        string calldata symbol
    ) external returns (address) {
        if (fee != 0 && feeRecipient == address(0)) revert SuperPoolFactory_ZeroFeeRecipient();
        SuperPool superPool = new SuperPool(POOL, asset, feeRecipient, fee, superPoolCap, name, symbol);
        superPool.transferOwnership(owner);
        isDeployerFor[address(superPool)] = true;

        // burn initial deposit
        IERC20(asset).safeTransferFrom(msg.sender, address(this), initialDepositAmt); // assume approval
        IERC20(asset).approve(address(superPool), initialDepositAmt);
        uint256 shares = superPool.deposit(initialDepositAmt, address(this));
        if (shares < MIN_BURNED_SHARES) revert SuperPoolFactory_TooFewInitialShares(shares);
        IERC20(superPool).transfer(DEAD_ADDRESS, shares);

        emit SuperPoolDeployed(owner, address(superPool), asset, name, symbol);
        return address(superPool);
    }
```

Even when the pool is creating, `newTotalAssets` used in `superPool.deposit(initialDepositAmt, address(this))` remains the current token balance in the contract, which can be transfered in advance.(Attackers can know the address generated by CREATE in advance)

We have the following two scenarios:

1. Superpool deployer choose a big `initialDepositAmt`.

Attacker can: inflate asset/share price.
  a. frontrun the deploy tx and push some(calculation based on step b) asset tokens to the address.
  b. in `deploySuperPool()`, factory only receive `MIN_BURNED_SHARES` -- internal deposit will be forced to be done at a inflated asset/share price.

Or attacker can: DoS the creation of pool.
  a. frontrun the deploy tx and push some(calculation based on step b) asset tokens to the address.
  b. in `deploySuperPool()`, factory cannot receive `MIN_BURNED_SHARES` -- creation will revert.

2. Superpool deployer choose a small `initialDepositAmt` (close to `MIN_BURNED_SHARES`).

Attacker can follow the classic inflation attack(link above) since burnt initial share is tiny and will not affect attacker`s profit.

## Impact

Victim will suffer great loss.
Attacker can easily provoke a permanent DoS on the Superpool.

## Code Snippet

https://github.com/sherlock-audit/2024-08-sentiment-v2/blob/main/protocol-v2/src/SuperPool.sol#L180

## Tool used

Manual Review

## Recommendation

Total assets should be tracked virtually.

